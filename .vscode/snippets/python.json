{
  "Clase Moderna Python": {
    "prefix": "class-modern",
    "body": [
      "from __future__ import annotations",
      "from typing import ClassVar, Optional",
      "from dataclasses import dataclass",
      "",
      "class ${1:ClassName}:",
      "    \"\"\"${2:Descripción de la clase siguiendo mejores prácticas 2024-2025}.\"\"\"",
      "    ",
      "    # Variables de clase con type hints",
      "    ${3:CLASS_CONSTANT}: ClassVar[${4:str}] = \"${5:value}\"",
      "    ",
      "    def __init__(self, ${6:param}: ${7:str}) -> None:",
      "        self._${6} = ${6}",
      "        ${8:# Inicialización adicional}",
      "    ",
      "    @property",
      "    def ${6}(self) -> ${7}:",
      "        \"\"\"${9:Getter de solo lectura}.\"\"\"",
      "        return self._${6}",
      "    ",
      "    def __repr__(self) -> str:",
      "        return f\"${1}(${6}={self.${6}!r})\"",
      "    ",
      "    def __eq__(self, other: object) -> bool:",
      "        if not isinstance(other, ${1}):",
      "            return NotImplemented",
      "        return self.${6} == other.${6}",
      "",
      "    ${10:# Métodos adicionales}"
    ],
    "description": "Clase Python moderna siguiendo mejores prácticas 2024-2025"
  },
  "Script Template": {
    "prefix": "script-template",
    "body": [
      "#!/usr/bin/env python3",
      "\"\"\"",
      "${1:Descripción del script}.",
      "Uso: python ${TM_FILENAME_BASE}.py [opciones]",
      "\"\"\"",
      "",
      "from __future__ import annotations",
      "from pathlib import Path",
      "from dataclasses import dataclass",
      "from typing import Optional",
      "import sys",
      "import logging",
      "",
      "# Configurar logging básico",
      "logging.basicConfig(",
      "    level=logging.INFO,",
      "    format='%(asctime)s - %(levelname)s - %(message)s'",
      ")",
      "logger = logging.getLogger(__name__)",
      "",
      "@dataclass",
      "class Config:",
      "    \"\"\"Configuración del script.\"\"\"",
      "    input_path: Path",
      "    output_path: Optional[Path] = None",
      "    verbose: bool = False",
      "    ",
      "    def __post_init__(self):",
      "        # Validación básica",
      "        if not self.input_path.exists():",
      "            raise FileNotFoundError(f\"No existe: {self.input_path}\")",
      "",
      "class ${2:ScriptName}:",
      "    \"\"\"Clase principal del script.\"\"\"",
      "    ",
      "    def __init__(self, config: Config):",
      "        self.config = config",
      "        self.resultados = []",
      "    ",
      "    def ejecutar(self) -> None:",
      "        \"\"\"Método principal de ejecución.\"\"\"",
      "        try:",
      "            logger.info(f\"Iniciando procesamiento: {self.config.input_path}\")",
      "            ",
      "            # Tu lógica aquí",
      "            ${3:pass}",
      "            ",
      "            logger.info(f\"Completado exitosamente. Procesados: {len(self.resultados)}\")",
      "            ",
      "        except KeyboardInterrupt:",
      "            logger.warning(\"Cancelado por usuario\")",
      "            sys.exit(1)",
      "        except Exception as e:",
      "            logger.error(f\"Error durante ejecución: {e}\")",
      "            sys.exit(1)",
      "",
      "def main() -> None:",
      "    \"\"\"Función principal con argumentos CLI.\"\"\"",
      "    import argparse",
      "    ",
      "    parser = argparse.ArgumentParser(description=\"${1}\")",
      "    parser.add_argument(\"input\", type=Path, help=\"Archivo o directorio de entrada\")",
      "    parser.add_argument(\"-o\", \"--output\", type=Path, help=\"Archivo de salida\")",
      "    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"Salida detallada\")",
      "    ",
      "    args = parser.parse_args()",
      "    ",
      "    if args.verbose:",
      "        logging.getLogger().setLevel(logging.DEBUG)",
      "    ",
      "    config = Config(",
      "        input_path=args.input,",
      "        output_path=args.output,",
      "        verbose=args.verbose",
      "    )",
      "    ",
      "    script = ${2}(config)",
      "    script.ejecutar()",
      "",
      "if __name__ == \"__main__\":",
      "    main()"
    ],
    "description": "Template completo para script Python con manejo de errores y CLI"
  },
  "Dataclass Pydantic": {
    "prefix": "dataclass-pydantic",
    "body": [
      "from pydantic import BaseModel, Field, field_validator",
      "from typing import Optional",
      "from datetime import datetime",
      "",
      "class ${1:ModelName}(BaseModel):",
      "    \"\"\"${2:Descripción del modelo con validación automática}.\"\"\"",
      "    ",
      "    ${3:field_name}: ${4:str} = Field(..., description=\"${5:Descripción del campo}\")",
      "    ${6:optional_field}: Optional[${7:int}] = Field(None, ge=0, description=\"${8:Campo opcional}\")",
      "    created_at: datetime = Field(default_factory=datetime.now)",
      "    ",
      "    model_config = {",
      "        \"use_enum_values\": True,",
      "        \"validate_assignment\": True,",
      "        \"extra\": \"forbid\",",
      "    }",
      "    ",
      "    @field_validator('${3}')",
      "    @classmethod",
      "    def validate_${3}(cls, v: str) -> str:",
      "        \"\"\"Validación personalizada para ${3}.\"\"\"",
      "        if not v or not v.strip():",
      "            raise ValueError('${3} no puede estar vacío')",
      "        return v.strip()",
      "",
      "    ${9:# Métodos adicionales}"
    ],
    "description": "Modelo Pydantic v2 con validación completa"
  },
  "Sales Command Service": {
    "prefix": "sales-service",
    "body": [
      "\"\"\"Servicio para ${1:Descripción del servicio}.\"\"\"",
      "",
      "from __future__ import annotations",
      "",
      "from typing import List, Optional",
      "from sqlalchemy.orm import Session",
      "",
      "from src.database.connection import get_db_session",
      "from src.database.models import ${2:ModelName}",
      "from src.utils.logging import get_logger",
      "",
      "logger = get_logger(__name__)",
      "",
      "",
      "class ${3:ServiceName}:",
      "    \"\"\"Servicio para gestionar ${1}.\"\"\"",
      "",
      "    def __init__(self) -> None:",
      "        \"\"\"Inicializar servicio.\"\"\"",
      "        self.logger = logger",
      "",
      "    def create(self, **kwargs) -> ${2}:",
      "        \"\"\"Crear nuevo ${1}.\"\"\"",
      "        with get_db_session() as session:",
      "            item = ${2}(**kwargs)",
      "            session.add(item)",
      "            session.commit()",
      "            session.refresh(item)",
      "            self.logger.info(f\"${2} creado: {item.id}\")",
      "            return item",
      "",
      "    def get_by_id(self, item_id: int) -> Optional[${2}]:",
      "        \"\"\"Obtener ${1} por ID.\"\"\"",
      "        with get_db_session() as session:",
      "            return session.query(${2}).filter(${2}.id == item_id).first()",
      "",
      "    def get_all(self) -> List[${2}]:",
      "        \"\"\"Obtener todos los ${1}.\"\"\"",
      "        with get_db_session() as session:",
      "            return session.query(${2}).all()",
      "",
      "    def update(self, item_id: int, **kwargs) -> Optional[${2}]:",
      "        \"\"\"Actualizar ${1}.\"\"\"",
      "        with get_db_session() as session:",
      "            item = session.query(${2}).filter(${2}.id == item_id).first()",
      "            if item:",
      "                for key, value in kwargs.items():",
      "                    setattr(item, key, value)",
      "                session.commit()",
      "                session.refresh(item)",
      "                self.logger.info(f\"${2} actualizado: {item.id}\")",
      "            return item",
      "",
      "    def delete(self, item_id: int) -> bool:",
      "        \"\"\"Eliminar ${1}.\"\"\"",
      "        with get_db_session() as session:",
      "            item = session.query(${2}).filter(${2}.id == item_id).first()",
      "            if item:",
      "                session.delete(item)",
      "                session.commit()",
      "                self.logger.info(f\"${2} eliminado: {item_id}\")",
      "                return True",
      "            return False",
      "",
      "    ${4:# Métodos específicos del servicio}"
    ],
    "description": "Servicio base para Sales Command con operaciones CRUD"
  },
  "Sales Command CLI": {
    "prefix": "sales-cli",
    "body": [
      "\"\"\"Comandos CLI para ${1:módulo}.\"\"\"",
      "",
      "from __future__ import annotations",
      "",
      "import typer",
      "from rich.console import Console",
      "from rich.table import Table",
      "",
      "from src.services.${2:service_name} import ${3:ServiceClass}",
      "from src.utils.logging import get_logger",
      "",
      "app = typer.Typer(help=\"${4:Descripción del módulo CLI}\")",
      "console = Console()",
      "logger = get_logger(__name__)",
      "",
      "",
      "@app.command()",
      "def add(",
      "    ${5:param}: ${6:str} = typer.Option(..., \"--${5}\", \"-${7:p}\", help=\"${8:Descripción del parámetro}\"),",
      "    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Salida detallada\")",
      ") -> None:",
      "    \"\"\"Agregar nuevo ${1}.\"\"\"",
      "    try:",
      "        service = ${3}()",
      "        result = service.create(${5}=${5})",
      "        ",
      "        if verbose:",
      "            console.print(f\"[green]✅ ${1} creado exitosamente:[/green]\")",
      "            console.print(f\"ID: {result.id}\")",
      "            console.print(f\"${5}: {result.${5}}\")",
      "        else:",
      "            console.print(f\"[green]✅ ${1} agregado: {result.${5}}[/green]\")",
      "            ",
      "    except Exception as e:",
      "        console.print(f\"[red]❌ Error al agregar ${1}: {e}[/red]\")",
      "        logger.error(f\"Error en add ${1}: {e}\")",
      "        raise typer.Exit(1)",
      "",
      "",
      "@app.command()",
      "def list() -> None:",
      "    \"\"\"Listar todos los ${1}.\"\"\"",
      "    try:",
      "        service = ${3}()",
      "        items = service.get_all()",
      "        ",
      "        if not items:",
      "            console.print(f\"[yellow]No hay ${1} registrados[/yellow]\")",
      "            return",
      "        ",
      "        table = Table(title=f\"Lista de ${1}\")",
      "        table.add_column(\"ID\", style=\"cyan\")",
      "        table.add_column(\"${5}\", style=\"green\")",
      "        table.add_column(\"Fecha\", style=\"blue\")",
      "        ",
      "        for item in items:",
      "            table.add_row(",
      "                str(item.id),",
      "                str(item.${5}),",
      "                item.created_at.strftime(\"%Y-%m-%d %H:%M\")",
      "            )",
      "        ",
      "        console.print(table)",
      "        ",
      "    except Exception as e:",
      "        console.print(f\"[red]❌ Error al listar ${1}: {e}[/red]\")",
      "        logger.error(f\"Error en list ${1}: {e}\")",
      "        raise typer.Exit(1)",
      "",
      "",
      "if __name__ == \"__main__\":",
      "    app()"
    ],
    "description": "Comando CLI completo para Sales Command"
  }
}
